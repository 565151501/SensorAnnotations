package com.dvoiss.sensorannotations;

import android.content.Context;
import android.support.annotation.NonNull;
import android.support.annotation.Nullable;
import android.util.Log;
import com.dvoiss.sensorannotations.internal.SensorBinder;
import java.lang.reflect.InvocationTargetException;
import java.util.LinkedHashMap;
import java.util.Map;

/**
 * Annotating methods as listeners for use with Android sensors.
 *
 * Binding needs a {@link Context} object to use to find the sensor manager. Binding can also be
 * done on a specific object with {@linkplain #bind(Object, Context)}.
 *
 * Per the best practices guidelines for sensors (<a href="https://developer.android.com/guide/topics/sensors/sensors_overview.html#sensors-practices">Sensors
 * Best Practices</a>), SensorAnnotations needs to be able to unregister listeners. This is best
 * done in an onPause method of the activity lifecycle.
 *
 * A good portion of this class is based on ButterKnife's binding code
 * (<a href="https://github.com/JakeWharton/butterknife">https://github.com/JakeWharton/butterknife</a>).
 */
public class SensorAnnotations {
    private static final boolean DEBUG_LOGGING = BuildConfig.DEBUG;
    private static final String TAG = SensorAnnotations.class.getSimpleName();

    private static final String ANDROID_PREFIX = "android.";
    private static final String JAVA_PREFIX = "java.";

    /**
     * The suffix will be added to the name of the generated class.
     */
    private static final String SUFFIX = "$$SensorBinder";

    static final SensorBinder NO_OP_VIEW_BINDER = new SensorBinder<Object>() {
        @Override
        public void bind(Object target) {}

        @Override
        public void unbind() {}
    };

    static final Map<Class<?>, SensorBinder> BINDER_CACHE = new LinkedHashMap<>();

    /**
     * Binding needs a context object to find the {@code SensorManager}. Binding will call the bind
     * method of the {@link SensorBinder} which will register a {@code SensorEventListener} that
     * will call the annotated methods.
     *
     * @param context {@link Context} Context object needed for finding the {@code SensorManager}.
     */
    public static void bind(@Nullable Context context) {
        bind(context, context);
    }

    /**
     * Alternative bind method for binding to classes that are not {@code Context} objects.
     *
     * @param target The target object being bound to.
     * @param context {@link Context} Context object needed for finding the {@code SensorManager}.
     */
    public static void bind(@Nullable Object target, @Nullable Context context) {
        if (target == null || context == null) {
            throw new RuntimeException("Bind method only accepts non-null parameters.");
        }

        Class<?> targetClass = target.getClass();
        try {
            if (DEBUG_LOGGING) {
                Log.d(TAG, "Looking up sensor binder for " + targetClass.getName());
            }

            SensorBinder sensorBinder = findSensorBinderToBind(target, context);
            if (sensorBinder != null) {
                //noinspection unchecked
                sensorBinder.bind(target);
            }
        } catch (Exception e) {
            throw new RuntimeException("Unable to bind sensors for " + targetClass.getName(), e);
        }
    }

    /**
     * Unbinding is important to do in {@code onPause} methods so we can un-register the {@code
     * SensorEventListener} Check the cache for the sensor binder and unbind.
     *
     * @param target The target object being bound to.
     */
    public static void unbind(@Nullable Object target) {
        if (target == null) {
            throw new RuntimeException(
                "Null value for target parameter passed into unbind method.");
        }

        Class<?> targetClass = target.getClass();
        try {
            if (DEBUG_LOGGING) {
                Log.d(TAG, "Looking up sensor binder for " + targetClass.getName());
            }

            SensorBinder sensorBinder = checkCacheForSensorBinderClass(target);
            if (sensorBinder != null) {
                sensorBinder.unbind();
            }
        } catch (Exception e) {
            throw new RuntimeException("Unable to unbind sensors for " + targetClass.getName(), e);
        }
    }

    /**
     * Find the class generated by the annotation processor that we need to bind.
     *
     * @param target The target object being bound to.
     * @param context {@link Context} Context object needed for finding the {@code SensorManager}.
     * @return The {@link SensorBinder} for the target or {@link #NO_OP_VIEW_BINDER}.
     * @throws IllegalAccessException
     * @throws InstantiationException
     */
    private static SensorBinder findSensorBinderToBind(@Nullable Object target,
        @Nullable Context context) throws IllegalAccessException, InstantiationException {
        if (target == null || context == null) {
            if (DEBUG_LOGGING) {
                Log.d(TAG, "Null parameters are not valid.");
            }
            return NO_OP_VIEW_BINDER;
        }

        SensorBinder sensorBinder = checkCacheForSensorBinderClass(target);
        if (sensorBinder != null) {
            if (DEBUG_LOGGING) {
                Log.d(TAG, "Loaded cached sensor binder.");
            }
            return sensorBinder;
        }

        Class<?> targetClass = target.getClass();
        String className = targetClass.getName();
        if (className.startsWith(ANDROID_PREFIX) || className.startsWith(JAVA_PREFIX)) {
            if (DEBUG_LOGGING) {
                Log.d(TAG, "Reached framework class. Abandoning search.");
            }
            return NO_OP_VIEW_BINDER;
        }

        try {
            Class<?> viewBindingClass = Class.forName(className + SUFFIX);

            sensorBinder =
                (SensorBinder) viewBindingClass.getConstructor(Context.class, targetClass)
                    .newInstance(context, target);

            if (sensorBinder == null) {
                if (DEBUG_LOGGING) {
                    Log.d(TAG, "Could not instantiate constructor for class.");
                }
                return NO_OP_VIEW_BINDER;
            }

            if (DEBUG_LOGGING) {
                Log.d(TAG, "Loaded sensor binder class.");
            }
        } catch (ClassNotFoundException e) {
            if (DEBUG_LOGGING) {
                Log.d(TAG, "Not found. Trying superclass " + targetClass.getSuperclass().getName());
            }
            sensorBinder = findSensorBinderToBind(targetClass.getSuperclass(), context);
        } catch (NoSuchMethodException e) {
            if (DEBUG_LOGGING) {
                Log.d(TAG, "Could not find constructor for class. Abandoning search.");
            }
            sensorBinder = NO_OP_VIEW_BINDER;
        } catch (InvocationTargetException e) {
            if (DEBUG_LOGGING) {
                Log.d(TAG, "Could not instantiate constructor for class.");
            }
            sensorBinder = NO_OP_VIEW_BINDER;
        }

        BINDER_CACHE.put(targetClass, sensorBinder);

        return sensorBinder;
    }

    /**
     * Check the cache for a {@link SensorBinder} that matches the target parameter.
     *
     * @param target The target object being bound to.
     * @return The cached {@link SensorBinder} for the target or null.
     */
    private static SensorBinder checkCacheForSensorBinderClass(@NonNull Object target) {
        Class<?> targetClass = target.getClass();
        SensorBinder sensorBinder = BINDER_CACHE.get(targetClass);
        return sensorBinder != null ? sensorBinder : null;
    }
}
